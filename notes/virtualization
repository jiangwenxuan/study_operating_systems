PROCESS:

mechanisms and policies

C's stack: local variables, function parameters, return addresses

C's heap: dynamically-allocated data

process states: running, ready, blocked

fork(), wait(), and exec()



MECHANISM: LIMITED DIRECT EXECUTION:

user mode and kernel mode

use trap instruction

use timer interrupt to help os maintain control of the machine

during a timer interrupt or system call, use context switch to change process


SCHEDULING: INTRODUCTION:

two scheduling metrics: turearound time, response time

five assumption:
1. each job runs for the same amount of time
2. all jobs arrive at the same time
3. once started, each job runs to completion
4. all jobs only use the cpu
5. the run-time of each job is known

First in, First out
Shortest Job First
Shortest Time-to-Completion First
Round Robin
Incorporating I/O

if there is no more oracle


SCHEDULING: THE MULTI-LEVEL FEEDBACK QUEUE:

rules:
1. if priority(a) > priority(b), a runs(b doesn't)
2. if priority(a) = priority(b), a & b run in round-robin fachion using the time slice of the given queue
3. while a job enters the system, it is placed at the highest priority(the topmost queue)
4. once a job uses up its time allotment at a given level(regardless of how many times it has given up the cpu, its prority is reduce
5. after some time period s, move all the jobs in the system to the topmost queue


SCHEDULING: PROPORTIONAL SHARE

the concept of proportional-share scheduling and briefly diccussed three approaches:
1. lottery scheduling: randomness to achieve proportional share
2. stride scheduling: deterministically
3. the completely fair scheduler of linux: weighted round-robin with dynamic time slices


THE ABSTRACTION: ADDRESS SPACES

virtual address, physical address

transparency, efficiency, protection


INTERLUDE: MEMORY API

malloc(), free() in c language

forget to allocate memory: segmentation fault
not allocate enough memory: buffer overflow
forget to initialize allocated memory: uninitialized read
forget to free memory: memory leak
free memory before you are done with it: dangling pointer
free memory repeatly: double free
call free() incorrectly: invalid frees


MECHANISM: ADDRESS TRANSLATION

to attain both efficiency and control while provide the desired virtulization, we use hardware support

rudimentaryly: just a few registers

hardware-based address translation(address translation): transforms the virtual address to physical address

dynamic(hardware-based) relocation: base and bounds
base and bounds registers are hardware struction kept on the chip
the part of the processor that helps with the address translation the memory management unit(MMU)

os need implement base-and-bounds version of virtual memory:
1. when a process is created, find space for its address space in memory
2. os must do some work when a process is terminated
3. os must perform a few additional steps when a context switch occurs 
4. os must provide exception handlers


SEGMENTATION

have a base and bounds pair per logical segment of the address space

a segment is just a contiguous portion of the address space of a particular length

segmentation allows the os to do is to place each one of those segments in different parts of physical memory, and thus avoid filling physical memory with unused virtual address space

calcualte the offset correctly

an explicit approach to refer to the segments

support for sharing

fined-grained and coarse-grained segmentation


FREE-SPACE MANAGEMENT

